// Copyright (c) 2025 hotflow2024
// Licensed under AGPL-3.0-or-later. See LICENSE for details.
// Commercial licensing available. See COMMERCIAL_LICENSE.md.
/**
 * AI Character Calibrator
 * 
 * 使用 AI 智能校准从剧本中提取的角色列表
 * 
 * 功能：
 * 1. 统计每个角色的出场次数、对白条数、出场集数
 * 2. AI 分析识别真正角色 vs 非角色词
 * 3. AI 合并重复角色（王总 = 投资人王总）
 * 4. AI 分类主角/配角/龙套（结合出场统计）
 * 5. AI 补充角色信息（年龄、性别、关系）
 */

import type { ScriptCharacter, ProjectBackground, EpisodeRawScript, CharacterIdentityAnchors, CharacterNegativePrompt } from '@/types/script';
import { callFeatureAPI } from '@/lib/ai/feature-router';
import { processBatched } from '@/lib/ai/batch-processor';
import { estimateTokens, safeTruncate } from '@/lib/ai/model-registry';

// ==================== 类型定义 ====================

export interface CharacterCalibrationResult {
  /** 校准后的角色列表 */
  characters: CalibratedCharacter[];
  /** 被过滤的词（非角色） */
  filteredWords: string[];
  /** 合并记录（哪些被合并到一起） */
  mergeRecords: MergeRecord[];
  /** AI 分析说明 */
  analysisNotes: string;
}

export interface CalibratedCharacter {
  id: string;
  name: string;
  /** 角色重要性：protagonist(主角), supporting(重要配角), minor(次要角色), extra(龙套) */
  importance: 'protagonist' | 'supporting' | 'minor' | 'extra';
  /** 出场集数范围 */
  episodeRange?: [number, number];
  /** 出场次数 */
  appearanceCount: number;
  /** AI 补充的角色描述 */
  role?: string;
  /** AI 推断的年龄 */
  age?: string;
  /** AI 推断的性别 */
  gender?: string;
  /** 与其他角色的关系 */
  relationships?: string;
  /** 原始提取的名字变体 */
  nameVariants: string[];
  // === 专业角色设计字段 ===
  /** 英文视觉提示词（用于AI图像生成） */
  visualPromptEn?: string;
  /** 中文视觉提示词 */
  visualPromptZh?: string;
  /** 面部特征描述 */
  facialFeatures?: string;
  /** 独特标记（疆痕、胎记等） */
  uniqueMarks?: string;
  /** 服装风格 */
  clothingStyle?: string;
  
  // === 6层身份锚点（角色一致性）===
  /** 身份锚点 - 6层特征锁定 */
  identityAnchors?: CharacterIdentityAnchors;
  /** 负面提示词 */
  negativePrompt?: CharacterNegativePrompt;
}

export interface MergeRecord {
  /** 最终使用的名字 */
  finalName: string;
  /** 被合并的变体 */
  variants: string[];
  /** 合并原因 */
  reason: string;
}

export interface CalibrationOptions {
  /** 上次校准的角色列表，用于合并确保角色不丢失 */
  previousCharacters?: CalibratedCharacter[];
}

// ==================== 从剧本重新提取角色 ====================

/**
 * 从 episodeRawScripts 中重新提取所有角色
 * 这会遍历所有集的所有场景，提取场景人物和对白说话人
 */
export function extractAllCharactersFromEpisodes(
  episodeScripts: EpisodeRawScript[]
): ScriptCharacter[] {
  const characterSet = new Set<string>();
  
  if (!episodeScripts || !Array.isArray(episodeScripts)) {
    console.warn('[extractAllCharactersFromEpisodes] episodeScripts 无效');
    return [];
  }
  
  // 遍历所有集
  for (const ep of episodeScripts) {
    if (!ep || !ep.scenes) continue;
    
    for (const scene of ep.scenes) {
      if (!scene) continue;
      
      // 从场景人物列表提取
      const sceneChars = scene.characters || [];
      for (const name of sceneChars) {
        if (name && name.trim()) {
          characterSet.add(name.trim());
        }
      }
      
      // 从对白中提取说话人
      const dialogues = scene.dialogues || [];
      for (const dialogue of dialogues) {
        if (dialogue && dialogue.character && dialogue.character.trim()) {
          characterSet.add(dialogue.character.trim());
        }
      }
    }
  }
  
  // 转换为 ScriptCharacter 数组
  const characters: ScriptCharacter[] = Array.from(characterSet).map((name, index) => ({
    id: `char_raw_${index + 1}`,
    name,
  }));
  
  console.log(`[extractAllCharactersFromEpisodes] 从 ${episodeScripts.length} 集剧本中提取到 ${characters.length} 个角色`);
  return characters;
}

// ==================== 出场统计 ====================

/** 角色出场统计 */
export interface CharacterStats {
  name: string;
  /** 场景出场次数 */
  sceneCount: number;
  /** 对白条数 */
  dialogueCount: number;
  /** 出场的集数列表 */
  episodes: number[];
  /** 首次出场集数 */
  firstEpisode: number;
  /** 最后出场集数 */
  lastEpisode: number;
  /** 对白样本（前3条） */
  dialogueSamples: string[];
  /** 出场场景样本 */
  sceneSamples: string[];
}

/**
 * 统计每个角色的出场情况
 */
export function collectCharacterStats(
  characterNames: string[],
  episodeScripts: EpisodeRawScript[]
): Map<string, CharacterStats> {
  const stats = new Map<string, CharacterStats>();
  
  // 防御性检查
  if (!characterNames || !Array.isArray(characterNames)) {
    console.warn('[collectCharacterStats] characterNames 无效');
    return stats;
  }
  if (!episodeScripts || !Array.isArray(episodeScripts)) {
    console.warn('[collectCharacterStats] episodeScripts 无效');
    return stats;
  }
  
  // 初始化
  for (const name of characterNames) {
    if (!name) continue;
    stats.set(name, {
      name,
      sceneCount: 0,
      dialogueCount: 0,
      episodes: [],
      firstEpisode: Infinity,
      lastEpisode: 0,
      dialogueSamples: [],
      sceneSamples: [],
    });
  }
  
  // 遍历所有剧本
  for (const ep of episodeScripts) {
    if (!ep || !ep.scenes) continue;
    const epIndex = ep.episodeIndex ?? 0;
    
    for (const scene of ep.scenes) {
      if (!scene) continue;
      
      // 检查场景人物
      const sceneChars = scene.characters || [];
      for (const charName of sceneChars) {
        if (!charName) continue;
        // 精确匹配或包含匹配
        for (const name of characterNames) {
          if (!name) continue;
          if (charName === name || charName.includes(name) || name.includes(charName)) {
            const s = stats.get(name);
            if (!s) continue;
            s.sceneCount++;
            if (!s.episodes.includes(epIndex)) {
              s.episodes.push(epIndex);
            }
            s.firstEpisode = Math.min(s.firstEpisode, epIndex);
            s.lastEpisode = Math.max(s.lastEpisode, epIndex);
            if (s.sceneSamples.length < 3) {
              s.sceneSamples.push(`第${epIndex}集: ${scene.sceneHeader || '未知场景'}`);
            }
          }
        }
      }
      
      // 检查对白
      const dialogues = scene.dialogues || [];
      for (const dialogue of dialogues) {
        if (!dialogue || !dialogue.character) continue;
        for (const name of characterNames) {
          if (!name) continue;
          if (dialogue.character === name || dialogue.character.includes(name)) {
            const s = stats.get(name);
            if (!s) continue;
            s.dialogueCount++;
            if (s.dialogueSamples.length < 3) {
              const line = dialogue.line || '';
              s.dialogueSamples.push(`${dialogue.character}: ${line.slice(0, 30)}...`);
            }
          }
        }
      }
    }
  }
  
  // 修正 Infinity
  for (const s of stats.values()) {
    if (s.firstEpisode === Infinity) s.firstEpisode = 0;
  }
  
  return stats;
}

// ==================== 核心函数 ====================

/**
 * 使用 AI 校准角色列表
 * 
 * @param rawCharacters 原始提取的角色列表
 * @param background 项目背景（大纲）
 * @param episodeScripts 分集剧本（提供上下文）
 * @param options API 配置
 */
export async function calibrateCharacters(
  rawCharacters: ScriptCharacter[],
  background: ProjectBackground,
  episodeScripts: EpisodeRawScript[],
  options?: CalibrationOptions
): Promise<CharacterCalibrationResult> {
  const previousCharacters = options?.previousCharacters;
  
  // 1. 先统计每个角色的出场情况
  const characterNames = rawCharacters.map(c => c.name);
  const stats = collectCharacterStats(characterNames, episodeScripts);
  
  // 2. 构建带统计信息的角色列表，按智能优先级排序
  const charsWithStats = rawCharacters.map(c => {
    const s = stats.get(c.name);
    const name = c.name;
    
    // 判断是否是群演（纯职业称呿、数字编号、群体描述）
    const isGroupExtra = [
      '保安', '警察', '员工', '护士', '医生', '记者', 
      '律师', '路人', '众人', '若干', '群众', '大妈',
    ].some(keyword => 
      name === keyword || 
      name === keyword + '1' || 
      name === keyword + '2' ||
      name.startsWith('几名') ||
      name.startsWith('两个') ||
      name.startsWith('若干')
    );
    
    // 判断是否有具体名字（中文名字2-4字，或有昵称后缀）
    const hasSpecificName = (
      (name.length >= 2 && name.length <= 4 && /[\u4e00-\u9fa5]/.test(name)) || // 中文名字
      name.includes('哥') || name.includes('姐') || name.includes('董') || // 有称呼
      name.includes('总') || name.includes('老') || name.includes('小') || // 有称呼
      /^[A-Z][a-z]+$/.test(name) // 英文名
    );
    
    return {
      name: c.name,
      sceneCount: s?.sceneCount || 0,
      dialogueCount: s?.dialogueCount || 0,
      episodeCount: s?.episodes.length || 0,
      isGroupExtra,
      hasSpecificName,
      // 智能优先级：有名字的优先，然后按出场排序
      priority: isGroupExtra ? -1000 : // 群演最低
                hasSpecificName ? 1000 + (s?.sceneCount || 0) + (s?.dialogueCount || 0) : // 有名字优先
                (s?.sceneCount || 0) + (s?.dialogueCount || 0), // 没名字按出场
    };
  }).sort((a, b) => b.priority - a.priority);
  
  // 限制发送给 AI 的角色数量，避免输出截断
  // 优先保留有名字的角色
  const maxCharsToSend = 150;
  const charsToProcess = charsWithStats.slice(0, maxCharsToSend);
  const skippedCount = charsWithStats.length - charsToProcess.length;
  
  // 3. 准备批处理 items（每个角色带上统计信息和对白样本）
  const batchItems = charsToProcess.map(c => ({
    name: c.name,
    sceneCount: c.sceneCount,
    dialogueCount: c.dialogueCount,
    episodeCount: c.episodeCount,
    dialogueSamples: stats.get(c.name)?.dialogueSamples || [],
  }));
  
  // 计算总场次数用于判断核心主角的 10% 阈值
  let totalSceneCount = 0;
  for (const ep of episodeScripts) {
    if (ep?.scenes) totalSceneCount += ep.scenes.length;
  }
  const coreThreshold = Math.max(Math.floor(totalSceneCount * 0.1), 10);
  
  const systemPrompt = `你是专业的影视剧本分析师，擅长从剧本数据中识别和校准角色。

【核心目标】
校准后的角色列表将用于生成角色三视图。
- **宽松保留：有名字或称呼的角色全部保留**
- **严格过滤：只过滤纯群演、群体、非角色词**

【严格执行 - 保留规则】

**1. 核心主角 (protagonist)** - 必须保留
   - 名字明确，出场多，贯穿全剧
   - 例：张明、老周、苏晴

**2. 重要配角 (supporting)** - 必须保留
   - 有具体名字或昵称：刀疤哥、龙哥、李强、王艳、小乐、阿强
   - 有固定称呼：赖董、王总、周总、李医生
   - 出场 ≥1 且有对白、或出场 ≥2

**3. 次要角色 (minor)** - 必须保留
   - 有具体名字，偶尔出场
   - 对剧情有一定作用
   - **只出场1次但有名字的也要保留！**

**4. 群演/配角 (extra)** - 尽量保留
   - 有称呼但出场极少的，标记为 extra
   - 例：李老头、小刘、王大妈

【极其重要 - 宽松筛选原则】
- **有名字的全部保留！**（即使只出场1次）
- **有称呼的全部保留！**（如老X、小X、X哥、X姐、X总、X董）
- **不确定的保留！**（宁可多保留，不要遗漏）

【严格过滤 - 只过滤这些】

**必须过滤的（无名字的纯群演）：**
- 纯职业词：保安、警察、护士、医生、记者、员工、律师、服务员、司机
- 数字编号：保安1、警察2、护士3、员工A
- 群体词：若干人、众人、几名保安、两个大妈、一群人
- 非角色词：全体员工、保安部、核心团队
- 描述词：眼框微湿、干练优雅、眼神沉静

**绝对不能过滤的：**
- 任何有姓名的：张明、李强、王艳、林风、马克
- 任何有昵称的：刀疤哥、龙哥、小乐、阿强、老李、小刘
- 有姓氏+职业：赖董、王总、周总、李医生、张秘书、林师傅
- 有姓氏+称谓：李老头、王大妈、周妹

【合并规则】
只合并明确是同一人的不同称呼：
- 例："王总" 和 "投资人王总" → 合并为 "王总"
- 例："刀疤哥" 和 "李强" 如果剧情明确是同一人 → 合并

【数量约束】
- 主角：1-3 个
- 配角：5-30 个（有名字的全部保留，不要限制）
- 总角色数：建议 15-40 个，宁多勿少

请以JSON格式返回分析结果。`;

  // 共享的背景上下文（每批都带，用 safeTruncate 截断）
  const outlineContext = safeTruncate(background.outline || '', 1500);
  const biosContext = safeTruncate(background.characterBios || '', 1000);

  // === 第一步：AI 角色分析（自动分批）===
  let parsed: any;
  try {
    console.log('[CharacterCalibrator] 开始 AI 角色分析...');
    
    // 闭包收集跨批次的聚合字段
    const allFilteredWords: string[] = [];
    const allMergeRecords: MergeRecord[] = [];
    const allAnalysisNotes: string[] = [];
    
    const { results: charResults, failedBatches } = await processBatched<
      typeof batchItems[number],
      any
    >({
      items: batchItems,
      feature: 'script_analysis',
      buildPrompts: (batch) => {
        // 每批构建独立的角色列表和对白样本
        const charList = batch.map((c, i) => {
          if (c.sceneCount === 0 && c.dialogueCount === 0) {
            return `${i + 1}. ${c.name} [未统计到出场]`;
          }
          return `${i + 1}. ${c.name} [出场${c.sceneCount}场, 对白${c.dialogueCount}条, 集数${c.episodeCount}]`;
        }).join('\n');
        
        const batchDialogues: string[] = [];
        for (const c of batch) {
          if (c.dialogueSamples.length > 0) {
            batchDialogues.push(`【${c.name}】`);
            batchDialogues.push(...c.dialogueSamples);
          }
        }
        
        const user = `【剧本信息】
剧名：《${background.title}》
${background.genre ? `类型：${background.genre}` : ''}
${background.era ? `时代背景：${background.era}` : ''}
${background.timelineSetting ? `时间线：${background.timelineSetting}` : ''}
总集数：${episodeScripts.length}集
总场次数：${totalSceneCount}场
核心主角阈值：出场 ≥ ${coreThreshold} 场

【故事大纲】
${outlineContext || '无'}

【人物小传】
${biosContext || '无'}

【待校准的角色列表 + 出场统计】（共${batch.length}个）
${charList}

【角色对白样本】
${batchDialogues.slice(0, 100).join('\n')}

请按照分级规则校准角色，返回JSON格式：
{
  "characters": [
    {
      "name": "角色名",
      "importance": "protagonist/supporting/minor/extra",
      "appearanceCount": 150,
      "dialogueCount": 200,
      "episodeSpan": [1, 60],
      "role": "角色描述",
      "age": "年龄",
      "gender": "性别",
      "relationships": "关系"
    }
  ],
  "filteredWords": ["被过滤的非角色词"],
  "mergeRecords": [
    { "finalName": "最终名", "variants": ["变体1", "变体2"], "reason": "原因" }
  ],
  "analysisNotes": "分析说明"
}

【极其重要！请特别注意】
1. 有名字的全部保留！有称呼的全部保留！不确定的保留！
2. 只过滤纯职业词、数字编号、群体词
3. 不要生成群演XX组标签`;
        return { system: systemPrompt, user };
      },
      parseResult: (raw) => {
        // 增强容错的 JSON 解析
        let cleaned = raw.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
        const jsonStart = cleaned.indexOf('{');
        const jsonEnd = cleaned.lastIndexOf('}');
        if (jsonStart !== -1 && jsonEnd !== -1) {
          cleaned = cleaned.slice(jsonStart, jsonEnd + 1);
        }
        
        let batchParsed: any;
        try {
          batchParsed = JSON.parse(cleaned);
        } catch (jsonErr) {
          console.warn('[CharacterCalibrator] 批次JSON解析失败，尝试修复...');
          const lastCompleteChar = cleaned.lastIndexOf('},');
          if (lastCompleteChar > 0) {
            const truncated = cleaned.slice(0, lastCompleteChar + 1);
            const fixedJson = truncated + '],"filteredWords":[],"mergeRecords":[],"analysisNotes":"部分结果"}';
            try {
              batchParsed = JSON.parse(fixedJson);
            } catch {
              const charsMatch = cleaned.match(/"characters"\s*:\s*\[(.*?)\]/s);
              if (charsMatch) {
                try {
                  const charsArray = JSON.parse('[' + charsMatch[1] + ']');
                  batchParsed = { characters: charsArray, filteredWords: [], mergeRecords: [], analysisNotes: '部分结果' };
                } catch {
                  throw jsonErr;
                }
              } else {
                throw jsonErr;
              }
            }
          } else {
            throw jsonErr;
          }
        }
        
        // 收集聚合字段
        allFilteredWords.push(...(batchParsed.filteredWords || []));
        allMergeRecords.push(...(batchParsed.mergeRecords || []));
        if (batchParsed.analysisNotes) allAnalysisNotes.push(batchParsed.analysisNotes);
        
        // 返回 Map<角色名, 角色数据>
        const map = new Map<string, any>();
        for (const c of (batchParsed.characters || [])) {
          if (c.name) map.set(c.name, c);
        }
        return map;
      },
      estimateItemTokens: (item) => estimateTokens(
        `${item.name} [出场${item.sceneCount}场, 对白${item.dialogueCount}条] ` +
        item.dialogueSamples.join(' ')
      ),
      estimateItemOutputTokens: () => 200,
      apiOptions: {
        temperature: 0,
        maxTokens: 16384,
      },
    });
    
    if (failedBatches > 0) {
      console.warn(`[CharacterCalibrator] ${failedBatches} 批次失败，使用部分结果`);
    }
    
    parsed = {
      characters: Array.from(charResults.values()),
      filteredWords: [...new Set(allFilteredWords)],
      mergeRecords: allMergeRecords,
      analysisNotes: allAnalysisNotes.join('; ') || '批处理完成',
    };
    
    console.log('[CharacterCalibrator] AI 角色分析成功，解析到', parsed.characters.length, '个角色');
  } catch (error) {
    const err = error instanceof Error ? error : new Error(String(error));
    console.error('[CharacterCalibrator] AI角色分析失败:', err.message);
    console.error('[CharacterCalibrator] 错误堆栈:', err.stack);
    // 返回原始数据作为降级方案，但带上统计信息
    return {
      characters: rawCharacters.map((c, i) => {
        const s = stats.get(c.name);
        return {
          id: c.id || `char_${i + 1}`,
          name: c.name,
          importance: (s && s.sceneCount > 20 ? 'supporting' : 
                       s && s.sceneCount > 5 ? 'minor' : 'extra') as any,
          appearanceCount: s?.sceneCount || 1,
          role: c.role,
          nameVariants: [c.name],
        };
      }),
      filteredWords: [],
      mergeRecords: [],
      analysisNotes: `AI角色分析失败(${err.message})，返回基于统计的结果`,
    };
  }
    
  // === 第二步：转换为标准格式并添加ID ===
  const characters: CalibratedCharacter[] = (parsed.characters || []).map((c: any, i: number) => ({
    id: `char_${i + 1}`,
    name: c.name,
    importance: c.importance || 'minor',
    appearanceCount: c.appearanceCount || c.dialogueCount || 1,
    role: c.role,
    age: c.age,
    gender: c.gender,
    relationships: c.relationships,
    nameVariants: c.nameVariants || [c.name],
    episodeRange: c.episodeSpan,
  }));
    
  // === 第三步：为主角和重要配角生成专业视觉提示词（独立 try/catch，失败不影响校准结果）===
  let enrichedCharacters = characters;
  try {
    enrichedCharacters = await enrichCharactersWithVisualPrompts(
      characters,
      background,
      episodeScripts
    );
    console.log('[CharacterCalibrator] 视觉提示词生成完成');
  } catch (enrichError) {
    const err = enrichError instanceof Error ? enrichError : new Error(String(enrichError));
    console.warn('[CharacterCalibrator] 视觉提示词生成失败（不影响角色校准结果）:', err.message);
    // enrichment 失败不影响主要校准结果，继续使用 characters
  }
    
  // === 第四步：合并上次校准结果，防止角色丢失 ===
  let finalCharacters = enrichedCharacters;
  if (previousCharacters && previousCharacters.length > 0) {
    const currentNames = new Set(enrichedCharacters.map(c => c.name));
    
    // 找出上次有但这次没有的角色（排除群演）
    const missingCharacters = previousCharacters.filter(pc => {
      if (currentNames.has(pc.name)) return false;
      // 只保留有具体名字的角色
      const isGroupExtra = [
        '保安', '警察', '员工', '护士', '医生', '记者', 
        '律师', '路人', '众人', '若干', '群众', '大妈',
      ].some(keyword => 
        pc.name === keyword || 
        pc.name === keyword + '1' || 
        pc.name === keyword + '2' ||
        pc.name.startsWith('几名') ||
        pc.name.startsWith('两个') ||
        pc.name.startsWith('若干')
      );
      return !isGroupExtra && pc.importance !== 'extra';
    });
    
    if (missingCharacters.length > 0) {
      console.log(`[CharacterCalibrator] 合并上次校准丢失的 ${missingCharacters.length} 个角色:`, 
        missingCharacters.map(c => c.name));
      
      // 为丢失的角色重新分配 ID
      const maxId = Math.max(...finalCharacters.map(c => {
        const match = c.id.match(/char_(\d+)/);
        return match ? parseInt(match[1]) : 0;
      }));
      
      const recoveredChars = missingCharacters.map((c, i) => ({
        ...c,
        id: `char_${maxId + i + 1}`,
      }));
      
      finalCharacters = [...finalCharacters, ...recoveredChars];
    }
  }
  
  return {
    characters: finalCharacters,
    filteredWords: parsed.filteredWords || [],
    mergeRecords: parsed.mergeRecords || [],
    analysisNotes: parsed.analysisNotes || '',
  };
}

/**
 * 收集角色出场上下文（用于AI分析）
 */
function collectCharacterContexts(
  characters: ScriptCharacter[],
  episodeScripts: EpisodeRawScript[]
): string {
  const contexts: string[] = [];
  const characterNames = new Set(characters.map(c => c.name));
  
  // 遍历剧本，收集角色出现的场景和对白
  for (const ep of episodeScripts.slice(0, 5)) { // 只取前5集作为样本
    for (const scene of ep.scenes.slice(0, 10)) { // 每集最多10个场景
      // 检查场景中是否有我们关注的角色
      const relevantChars = scene.characters.filter(c => 
        characterNames.has(c) || characters.some(char => c.includes(char.name))
      );
      
      if (relevantChars.length > 0) {
        contexts.push(`[第${ep.episodeIndex}集-${scene.sceneHeader}]`);
        contexts.push(`人物: ${relevantChars.join(', ')}`);
        
        // 收集相关对白（前3条）
        const relevantDialogues = scene.dialogues
          .filter(d => characterNames.has(d.character) || characters.some(c => d.character.includes(c.name)))
          .slice(0, 3);
        
        for (const d of relevantDialogues) {
          contexts.push(`${d.character}: ${d.line.slice(0, 50)}...`);
        }
        contexts.push('');
      }
    }
  }
  
  return contexts.join('\n');
}

/**
 * 将校准结果转换回 ScriptCharacter 格式
 * 注意：保留原始角色的所有字段，只补充/更新 AI 校准的字段
 */
export function convertToScriptCharacters(
  calibrated: CalibratedCharacter[],
  originalCharacters?: ScriptCharacter[]
): ScriptCharacter[] {
  return calibrated.map(c => {
    // 查找原始角色数据
    const original = originalCharacters?.find(orig => orig.name === c.name);
    
    // 合并：保留原始数据，只补充/更新 AI 生成的字段
    return {
      // 保留原始字段
      ...original,
      // 更新/补充 AI 校准的字段
      id: c.id,
      name: c.name,
      role: c.role || original?.role,
      age: c.age || original?.age,
      gender: c.gender || original?.gender,
      relationships: c.relationships || original?.relationships,
      // === 专业角色设计字段（世界级大师生成）===
      visualPromptEn: c.visualPromptEn || original?.visualPromptEn,
      visualPromptZh: c.visualPromptZh || original?.visualPromptZh,
      appearance: c.facialFeatures || c.uniqueMarks || c.clothingStyle 
        ? [c.facialFeatures, c.uniqueMarks, c.clothingStyle].filter(Boolean).join(', ')
        : original?.appearance,
      // === 6层身份锚点（角色一致性）===
      identityAnchors: c.identityAnchors || original?.identityAnchors,
      negativePrompt: c.negativePrompt || original?.negativePrompt,
      // 标记重要性，便于UI展示
      tags: [c.importance, `出场${c.appearanceCount}次`, ...(original?.tags || [])],
    };
  });
}

/**
 * 按重要性排序角色
 */
export function sortByImportance(characters: CalibratedCharacter[]): CalibratedCharacter[] {
  const order = { protagonist: 0, supporting: 1, minor: 2, extra: 3 };
  return [...characters].sort((a, b) => {
    // 先按重要性
    const importanceOrder = order[a.importance] - order[b.importance];
    if (importanceOrder !== 0) return importanceOrder;
    // 再按出场次数
    return b.appearanceCount - a.appearanceCount;
  });
}

// ==================== 专业角色设计 ====================

/**
 * 为主角和重要配角生成专业的视觉提示词
 * 调用世界级角色设计大师 AI
 */
async function enrichCharactersWithVisualPrompts(
  characters: CalibratedCharacter[],
  background: ProjectBackground,
  episodeScripts: EpisodeRawScript[]
): Promise<CalibratedCharacter[]> {
  // 只为主角和重要配角生成详细提示词
  const keyCharacters = characters.filter(c => 
    c.importance === 'protagonist' || c.importance === 'supporting'
  );
  
  if (keyCharacters.length === 0) {
    return characters;
  }
  
  console.log(`[enrichCharactersWithVisualPrompts] 为 ${keyCharacters.length} 个关键角色生成专业提示词...`);
  
  // 构建时代服装指导
  const getEraFashionGuidance = () => {
    const startYear = background.storyStartYear;
    const timeline = background.timelineSetting || background.era || '现代';
    
    if (startYear) {
      if (startYear >= 2020) {
        return `【${startYear}年代服装指导】
- 年轻人：休闲时尚、运动风、潮牌元素，常穿卫衣、牢仔裤、运动鞋
- 中年人：商务休闲、简约现代，常穿Polo衫、休闲西装、卡其裤
- 老年人：舒适休闲，常穿开衫、孖子衫、布鞋或运动鞋`;
      } else if (startYear >= 2010) {
        return `【${startYear}年代服装指导】
- 年轻人：韩系时尚、小清新风格，常穿T恤、牢仔裤、帆布鞋
- 中年人：商务正装或商务休闲，常穿西装、衬衫、皮鞋
- 老年人：传统休闲，常穿开衫、布鞋`;
      } else if (startYear >= 2000) {
        return `【${startYear}年代服装指导】
- 年轻人：千禅年时尚，常穿紧身裤、宽松外套、板鞋
- 中年人：正式商务装，常穿西装套装、领带、皮鞋
- 老年人：中山装或简单开衫、布鞋`;
      } else if (startYear >= 1990) {
        return `【${startYear}年代服装指导】
- 年轻人：喝叭裤、确良外套、大肩垫西装、特宾球鞋
- 中年人：中山装或西装，常穿解放鞋或简单皮鞋
- 老年人：中山装、棉袄、布鞋`;
      } else {
        return `【${startYear}年代服装指导】
请根据该年代的中国实际服装风格设计，避免古装或不符合时代的服装`;
      }
    }
    
    // 如果没有精确年份，根据 era 判断
    if (timeline.includes('现代') || timeline.includes('当代')) {
      return `【现代服装指导】
请设计符合当代中国的服装风格，年轻人穿时尚休闲装，中年人穿商务休闲装，老年人穿舒适传统服装。
绝对不要设计成古装、汉服、或古代服饰。`;
    }
    
    return '';
  };
  
  const eraFashionGuidance = getEraFashionGuidance();
  
  // 系统提示词：角色设计大师 + 背景信息 + 输出格式（不含具体角色）
  const systemPrompt = `你是好莱坞顶级角色设计大师，曾为漫威、迪士尼、皮克斯设计过无数经典角色。

你的专业能力：
- **角色视觉设计**：能准确捕捉角色的外在形象、服装风格、肢体语言
- **年代服装专家**：精通不同年代的中国服装潮流，能准确还原历史时期的服装特征
- **AI图像生成专家**：深谙 Midjourney、DALL-E、Stable Diffusion 等 AI 绘图模型
- **角色一致性专家**：掌握"6层特征锁定"技术，确保同一角色在不同场景保持一致

【剧本信息】
剧名：《${background.title}》
类型：${background.genre || '未知类型'}
时代背景：${background.era || '现代'}
精确时间线：${background.timelineSetting || '未指定'}
故事年份：${background.storyStartYear ? `${background.storyStartYear}年` : '未指定'}${background.storyEndYear && background.storyEndYear !== background.storyStartYear ? ` - ${background.storyEndYear}年` : ''}
总集数：${episodeScripts.length}集

${eraFashionGuidance}

【故事大纲】
${background.outline?.slice(0, 1200) || '无'}

【人物小传】
${background.characterBios?.slice(0, 1200) || '无'}

【核心输出：6层身份锚点】
这是AI生图中保持角色一致性的关键技术，必须详细填写：

① 骨相层（面部骨骼结构）
   - faceShape: 脸型（oval/square/heart/round/diamond/oblong）
   - jawline: 下颌线（sharp angular/soft rounded/prominent）
   - cheekbones: 颧骨（high prominent/subtle/wide set）

② 五官层（精确描述）
   - eyeShape: 眼型（almond/round/hooded/monolid/upturned）
   - eyeDetails: 眼部细节（double eyelids, slight epicanthic fold, deep-set）
   - noseShape: 鼻型（straight bridge, rounded tip, button nose）
   - lipShape: 唇型（full lips, thin lips, defined cupid's bow）

③ 辨识标记层（最强锚点！）
   - uniqueMarks: 必填数组！至少2-3个独特标记
   - 示例：["small mole 2cm below left eye", "faint scar on right eyebrow", "dimple on left cheek"]
   - 这是最强的角色识别特征，必须精确到位置

④ 色彩锚点层（Hex色值）
   - colorAnchors.iris: 虹膜色（如 #3D2314 dark brown）
   - colorAnchors.hair: 发色（如 #1A1A1A jet black）
   - colorAnchors.skin: 肤色（如 #E8C4A0 warm beige）
   - colorAnchors.lips: 唇色（如 #C4727E dusty rose）

⑤ 皮肤纹理层
   - skinTexture: 皮肤质感（visible pores, light freckles, smile lines）

⑥ 发型锚点层
   - hairStyle: 发型（shoulder-length layered, buzz cut, bob）
   - hairlineDetails: 发际线（natural, widow's peak, receding）

【负面提示词】
为角色生成negativePrompt，排除不符合设定的特征：
- avoid: 要避免的特征（如中国人角色应避免 blonde hair, blue eyes）
- styleExclusions: 风格排除（如 anime style, cartoon, painting）

【服装要求】
- 服装必须符合故事发生的年代（${background.storyStartYear || background.era || '现代'}）
- 根据角色年龄设计合适的服装
- 绝对不要设计成古装、汉服、或不符合时代的服饰

请返回JSON格式（注意：只返回单个角色对象，不要数组包裹）：
{
  "name": "角色名",
  "detailedDescription": "详细的中文角色描述（100-200字）",
  "visualPromptEn": "English visual prompt, 40-60 words",
  "visualPromptZh": "中文视觉提示词",
  "clothingStyle": "符合年代的服装风格",
  "identityAnchors": {
    "faceShape": "oval",
    "jawline": "soft rounded",
    "cheekbones": "subtle",
    "eyeShape": "almond",
    "eyeDetails": "double eyelids, warm gaze",
    "noseShape": "straight bridge, rounded tip",
    "lipShape": "full lips",
    "uniqueMarks": ["small mole below left eye", "dimple on right cheek"],
    "colorAnchors": {
      "iris": "#3D2314",
      "hair": "#1A1A1A",
      "skin": "#E8C4A0",
      "lips": "#C4727E"
    },
    "skinTexture": "smooth with light smile lines",
    "hairStyle": "short neat business cut",
    "hairlineDetails": "natural hairline"
  },
  "negativePrompt": {
    "avoid": ["blonde hair", "blue eyes", "beard", "tattoos"],
    "styleExclusions": ["anime", "cartoon", "painting", "sketch"]
  }
}`;

  // 逐个角色调用 AI，避免一次性输出过多 JSON 导致推理模型 token 耗尽
  const designMap = new Map<string, any>();
  
  for (let i = 0; i < keyCharacters.length; i++) {
    const c = keyCharacters[i];
    const charLabel = `${c.name}（${c.importance === 'protagonist' ? '主角' : '重要配角'}）`;
    console.log(`[enrichCharactersWithVisualPrompts] [${i + 1}/${keyCharacters.length}] 生成: ${charLabel}`);
    
    const userPrompt = `请为以下角色生成专业视觉提示词和6层身份锚点：

${c.name}（${c.importance === 'protagonist' ? '主角' : '重要配角'}）
- 身份：${c.role || '未知'}
- 年龄：${c.age || '未知'}
- 性别：${c.gender || '未知'}
- 出场：${c.appearanceCount}次`;
    
    try {
      const result = await callFeatureAPI('script_analysis', systemPrompt, userPrompt, {
        maxTokens: 4096, // 单角色输出 4096 足够
      });
      
      // 解析单角色 JSON
      let cleaned = result.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
      const jsonStart = cleaned.indexOf('{');
      const jsonEnd = cleaned.lastIndexOf('}');
      if (jsonStart !== -1 && jsonEnd !== -1) {
        cleaned = cleaned.slice(jsonStart, jsonEnd + 1);
      }
      
      const parsed = JSON.parse(cleaned);
      // 兼容：AI 可能返回 { characters: [...] } 或直接返回单角色对象
      const design = parsed.characters ? parsed.characters[0] : parsed;
      if (design) {
        designMap.set(design.name || c.name, design);
        console.log(`[enrichCharactersWithVisualPrompts] ✅ ${c.name} 生成成功`);
      }
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      console.warn(`[enrichCharactersWithVisualPrompts] ⚠️ ${c.name} 生成失败（不影响其他角色）:`, err.message);
      // 单个角色失败不影响整体，继续处理下一个
    }
  }
  
  console.log(`[enrichCharactersWithVisualPrompts] 完成: ${designMap.size}/${keyCharacters.length} 个角色生成成功`);
  
  // 合并到角色数据
  return characters.map(c => {
    const design = designMap.get(c.name);
    if (design) {
      // 提取 identityAnchors
      const anchors = design.identityAnchors;
      
      // 从新的 identityAnchors 中提取兼容字段
      const facialFeatures = anchors ? [
        anchors.faceShape && `Face: ${anchors.faceShape}`,
        anchors.eyeShape && `Eyes: ${anchors.eyeShape}`,
        anchors.eyeDetails,
        anchors.noseShape && `Nose: ${anchors.noseShape}`,
        anchors.lipShape && `Lips: ${anchors.lipShape}`,
      ].filter(Boolean).join(', ') : design.facialFeatures;
      
      // uniqueMarks 从 anchors.uniqueMarks 数组转换为字符串（向后兼容）
      const uniqueMarks = anchors?.uniqueMarks 
        ? (Array.isArray(anchors.uniqueMarks) ? anchors.uniqueMarks.join('; ') : anchors.uniqueMarks)
        : design.uniqueMarks;
      
      return {
        ...c,
        role: design.detailedDescription || c.role,
        visualPromptEn: design.visualPromptEn,
        visualPromptZh: design.visualPromptZh,
        facialFeatures,
        uniqueMarks,
        clothingStyle: design.clothingStyle,
        // 新增：6层身份锚点
        identityAnchors: anchors,
        // 新增：负面提示词
        negativePrompt: design.negativePrompt,
      };
    }
    return c;
  });
}
